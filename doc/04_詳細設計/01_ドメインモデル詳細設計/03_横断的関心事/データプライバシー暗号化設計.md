# SES管理システム - データプライバシー・暗号化設計

## 1. データ分類とプライバシー要件

### 1.1 データ分類体系
```
データ分類レベル:
├── Level 1: 公開情報 (Public)
│   ├── システム設定情報
│   ├── マスタデータ（スキル名等）
│   └── 統計データ（匿名化済み）
├── Level 2: 社内限定 (Internal)
│   ├── プロジェクト基本情報
│   ├── 契約金額情報
│   └── 業務実績データ
├── Level 3: 機密情報 (Confidential)
│   ├── 顧客企業情報
│   ├── 個人スキル詳細
│   └── 勤務評価情報
└── Level 4: 極秘情報 (Highly Confidential)
    ├── 個人識別情報 (PII)
    ├── マイナンバー等
    └── 給与・報酬情報
```

### 1.2 GDPR/個人情報保護法対応
```java
/**
 * 個人データ保護アノテーション
 */
@Target({ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PersonalData {
    /**
     * データ分類レベル
     */
    DataClassification classification() default DataClassification.CONFIDENTIAL;
    
    /**
     * 暗号化必須フラグ
     */
    boolean encryptionRequired() default true;
    
    /**
     * マスキング必須フラグ
     */
    boolean maskingRequired() default false;
    
    /**
     * データ保持期間（年）
     */
    int retentionYears() default 7;
    
    /**
     * 削除権対象フラグ（GDPR Article 17）
     */
    boolean rightToErasure() default true;
    
    /**
     * ポータビリティ権対象フラグ（GDPR Article 20）
     */
    boolean rightToPortability() default true;
    
    /**
     * 処理目的
     */
    String[] processingPurposes() default {};
    
    /**
     * 法的根拠
     */
    LegalBasis legalBasis() default LegalBasis.LEGITIMATE_INTEREST;
    
    enum DataClassification {
        PUBLIC, INTERNAL, CONFIDENTIAL, HIGHLY_CONFIDENTIAL
    }
    
    enum LegalBasis {
        CONSENT,              // 同意
        CONTRACT,             // 契約履行
        LEGAL_OBLIGATION,     // 法的義務
        VITAL_INTERESTS,      // 生命に関わる利益
        PUBLIC_TASK,          // 公的業務
        LEGITIMATE_INTEREST   // 正当な利益
    }
}
```

## 2. 暗号化アーキテクチャ

### 2.1 暗号化アーキテクチャ概要
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Application    │    │ Encryption      │    │ Key Management  │
│  Layer          │    │ Service         │    │ Service (KMS)   │
│                 │    │                 │    │                 │
│ ・Entity保存    │───►│・フィールド暗号化│───►│・キー生成       │
│ ・データ参照    │    │・復号化         │    │・キーローテーション│
│ ・検索処理      │    │・検索可能暗号化  │    │・アクセス制御   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Database       │    │ Audit Service   │    │ Backup Service  │
│                 │    │                 │    │                 │
│ ・暗号化済み保存│    │・アクセスログ   │    │・暗号化バックアップ│
│ ・インデックス  │    │・操作ログ       │    │・キー分離保存   │
│ ・パフォーマンス│    │・異常検知       │    │・復旧手順       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 暗号化サービス実装
```java
@Service
public class EncryptionService {
    private final KeyManagementService keyService;
    private final AuditService auditService;
    
    // AES-256-GCM for field-level encryption
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;
    
    /**
     * フィールドレベル暗号化
     */
    public EncryptedData encrypt(Object data, DataClassification classification) {
        if (data == null) {
            return null;
        }
        
        try {
            // データ分類に応じたキー取得
            EncryptionKey key = keyService.getKey(classification);
            
            // データの文字列化
            String plaintext = objectToJson(data);
            byte[] plaintextBytes = plaintext.getBytes(StandardCharsets.UTF_8);
            
            // 暗号化実行
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            byte[] iv = generateIV();
            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key.getSecretKey(), gcmSpec);
            
            byte[] encryptedBytes = cipher.doFinal(plaintextBytes);
            
            // 監査ログ
            auditService.logEncryption(key.getKeyId(), classification, plaintextBytes.length);
            
            return new EncryptedData(
                Base64.getEncoder().encodeToString(encryptedBytes),
                Base64.getEncoder().encodeToString(iv),
                key.getKeyId(),
                Instant.now()
            );
            
        } catch (Exception e) {
            auditService.logEncryptionFailure(classification, e.getMessage());
            throw new EncryptionException("Encryption failed", e);
        }
    }
    
    /**
     * フィールドレベル復号化
     */
    public <T> T decrypt(EncryptedData encryptedData, Class<T> targetType) {
        if (encryptedData == null) {
            return null;
        }
        
        try {
            // キー取得
            EncryptionKey key = keyService.getKey(encryptedData.getKeyId());
            
            // 復号化実行
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            byte[] iv = Base64.getDecoder().decode(encryptedData.getIv());
            byte[] encryptedBytes = Base64.getDecoder().decode(encryptedData.getData());
            
            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, key.getSecretKey(), gcmSpec);
            
            byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
            String decryptedText = new String(decryptedBytes, StandardCharsets.UTF_8);
            
            // 監査ログ
            auditService.logDecryption(encryptedData.getKeyId(), targetType.getSimpleName());
            
            return jsonToObject(decryptedText, targetType);
            
        } catch (Exception e) {
            auditService.logDecryptionFailure(encryptedData.getKeyId(), e.getMessage());
            throw new DecryptionException("Decryption failed", e);
        }
    }
    
    /**
     * 検索可能暗号化（Deterministic Encryption）
     */
    public String encryptForSearch(String plaintext, DataClassification classification) {
        if (plaintext == null || plaintext.isEmpty()) {
            return null;
        }
        
        try {
            // 検索用キー（固定IV使用）
            EncryptionKey searchKey = keyService.getSearchKey(classification);
            
            // HMAC-SHA256による決定的暗号化
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(searchKey.getSecretKey());
            byte[] hashBytes = mac.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
            
            return Base64.getEncoder().encodeToString(hashBytes);
            
        } catch (Exception e) {
            throw new EncryptionException("Search encryption failed", e);
        }
    }
    
    /**
     * データマスキング
     */
    public String mask(String data, MaskingType type) {
        if (data == null || data.isEmpty()) {
            return data;
        }
        
        switch (type) {
            case EMAIL:
                return maskEmail(data);
            case PHONE:
                return maskPhone(data);
            case CREDIT_CARD:
                return maskCreditCard(data);
            case NAME:
                return maskName(data);
            case PARTIAL:
                return maskPartial(data);
            default:
                return "***MASKED***";
        }
    }
    
    private String maskEmail(String email) {
        if (!email.contains("@")) return "***@***.***";
        
        String[] parts = email.split("@");
        String localPart = parts[0];
        String domain = parts[1];
        
        String maskedLocal = localPart.length() > 2 ? 
            localPart.substring(0, 2) + "***" : "***";
        String maskedDomain = domain.contains(".") ? 
            "***." + domain.substring(domain.lastIndexOf(".") + 1) : "***";
            
        return maskedLocal + "@" + maskedDomain;
    }
    
    private String maskPhone(String phone) {
        String digits = phone.replaceAll("[^0-9]", "");
        if (digits.length() < 4) return "***-***-****";
        
        return "***-***-" + digits.substring(digits.length() - 4);
    }
    
    private String maskName(String name) {
        if (name.length() <= 1) return "*";
        if (name.length() <= 3) return name.charAt(0) + "*";
        
        return name.charAt(0) + "***" + name.charAt(name.length() - 1);
    }
    
    private String maskPartial(String data) {
        if (data.length() <= 4) return "***";
        
        int visibleChars = Math.min(2, data.length() / 4);
        return data.substring(0, visibleChars) + "***" + 
               data.substring(data.length() - visibleChars);
    }
    
    private byte[] generateIV() {
        byte[] iv = new byte[GCM_IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        return iv;
    }
    
    private String objectToJson(Object obj) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.writeValueAsString(obj);
    }
    
    private <T> T jsonToObject(String json, Class<T> type) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, type);
    }
    
    public enum MaskingType {
        EMAIL, PHONE, CREDIT_CARD, NAME, PARTIAL, FULL
    }
}
```

### 2.3 暗号化データクラス
```java
@Embeddable
public class EncryptedData {
    private String data;              // Base64エンコードされた暗号化データ
    private String iv;                // Base64エンコードされたIV
    private String keyId;             // 暗号化キーID
    private Instant encryptedAt;      // 暗号化日時
    
    public EncryptedData() {}
    
    public EncryptedData(String data, String iv, String keyId, Instant encryptedAt) {
        this.data = data;
        this.iv = iv;
        this.keyId = keyId;
        this.encryptedAt = encryptedAt;
    }
    
    // ゲッター・セッターメソッド省略
}
```

## 3. 個人データ管理エンティティ

### 3.1 PersonalDataEntity（個人データ基底クラス）
```java
@MappedSuperclass
public abstract class PersonalDataEntity {
    
    /**
     * データ主体（本人）の同意管理
     */
    @Embedded
    private ConsentManagement consentManagement;
    
    /**
     * データ保持期間管理
     */
    @Embedded
    private RetentionManagement retentionManagement;
    
    /**
     * アクセス履歴
     */
    @ElementCollection
    private List<DataAccessLog> accessLogs;
    
    /**
     * 削除要求フラグ
     */
    private boolean deletionRequested;
    private LocalDateTime deletionRequestedAt;
    private String deletionReason;
    
    /**
     * 匿名化フラグ
     */
    private boolean anonymized;
    private LocalDateTime anonymizedAt;
    
    /**
     * GDPR権利行使記録
     */
    @ElementCollection
    private List<RightsExerciseLog> rightsExercises;
    
    /**
     * データアクセス記録
     */
    public void recordAccess(String userId, String purpose) {
        DataAccessLog log = new DataAccessLog();
        log.setUserId(userId);
        log.setPurpose(purpose);
        log.setAccessedAt(LocalDateTime.now());
        log.setIpAddress(getCurrentIpAddress());
        
        this.accessLogs.add(log);
        
        // 異常アクセス検知
        detectAnomalousAccess();
    }
    
    /**
     * 削除権行使（GDPR Article 17）
     */
    public void requestDeletion(String reason, String requesterId) {
        this.deletionRequested = true;
        this.deletionRequestedAt = LocalDateTime.now();
        this.deletionReason = reason;
        
        RightsExerciseLog log = new RightsExerciseLog();
        log.setRightType(GDPRRight.RIGHT_TO_ERASURE);
        log.setRequesterId(requesterId);
        log.setRequestedAt(LocalDateTime.now());
        log.setReason(reason);
        
        this.rightsExercises.add(log);
    }
    
    /**
     * 匿名化実行
     */
    public void anonymize() {
        if (this.anonymized) {
            return;
        }
        
        anonymizePersonalData();
        
        this.anonymized = true;
        this.anonymizedAt = LocalDateTime.now();
    }
    
    /**
     * データポータビリティ権対応（GDPR Article 20）
     */
    public PersonalDataExport exportPersonalData() {
        PersonalDataExport export = new PersonalDataExport();
        export.setDataSubjectId(getDataSubjectId());
        export.setExportedAt(LocalDateTime.now());
        export.setData(collectPersonalData());
        export.setFormat("JSON");
        
        RightsExerciseLog log = new RightsExerciseLog();
        log.setRightType(GDPRRight.RIGHT_TO_PORTABILITY);
        log.setRequestedAt(LocalDateTime.now());
        
        this.rightsExercises.add(log);
        
        return export;
    }
    
    /**
     * 保持期間チェック
     */
    public boolean isRetentionPeriodExpired() {
        return retentionManagement.isExpired();
    }
    
    /**
     * 同意状況チェック
     */
    public boolean hasValidConsent(String purpose) {
        return consentManagement.hasValidConsent(purpose);
    }
    
    // 抽象メソッド
    protected abstract String getDataSubjectId();
    protected abstract void anonymizePersonalData();
    protected abstract Map<String, Object> collectPersonalData();
    
    private void detectAnomalousAccess() {
        // 異常アクセスパターンの検知ロジック
        long recentAccesses = accessLogs.stream()
            .filter(log -> log.getAccessedAt().isAfter(LocalDateTime.now().minusHours(1)))
            .count();
            
        if (recentAccesses > 100) {
            // アラート送信
            SecurityAlertService.sendAnomalousAccessAlert(getDataSubjectId(), recentAccesses);
        }
    }
    
    private String getCurrentIpAddress() {
        // 現在のリクエストのIPアドレス取得
        return RequestContextHolder.getRequestIpAddress();
    }
}
```

### 3.2 ConsentManagement（同意管理）
```java
@Embeddable
public class ConsentManagement {
    
    @ElementCollection
    private Map<String, ConsentRecord> consents; // 目的別同意記録
    
    /**
     * 同意の記録
     */
    public void recordConsent(String purpose, ConsentType type, String legalBasis) {
        ConsentRecord record = new ConsentRecord();
        record.setPurpose(purpose);
        record.setType(type);
        record.setLegalBasis(legalBasis);
        record.setGrantedAt(LocalDateTime.now());
        record.setVersion("1.0");
        record.setActive(true);
        
        consents.put(purpose, record);
    }
    
    /**
     * 同意の撤回
     */
    public void withdrawConsent(String purpose, String reason) {
        ConsentRecord record = consents.get(purpose);
        if (record != null) {
            record.setActive(false);
            record.setWithdrawnAt(LocalDateTime.now());
            record.setWithdrawalReason(reason);
        }
    }
    
    /**
     * 有効な同意の確認
     */
    public boolean hasValidConsent(String purpose) {
        ConsentRecord record = consents.get(purpose);
        return record != null && record.isActive() && !record.isExpired();
    }
    
    /**
     * 同意履歴のエクスポート
     */
    public List<ConsentRecord> exportConsentHistory() {
        return new ArrayList<>(consents.values());
    }
    
    @Embeddable
    public static class ConsentRecord {
        private String purpose;               // 処理目的
        private ConsentType type;            // 同意タイプ
        private String legalBasis;           // 法的根拠
        private LocalDateTime grantedAt;     // 同意日時
        private LocalDateTime withdrawnAt;    // 撤回日時
        private String withdrawalReason;      // 撤回理由
        private String version;              // 同意バージョン
        private boolean active;              // 有効フラグ
        private LocalDateTime expiresAt;     // 有効期限
        
        public boolean isExpired() {
            return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);
        }
        
        // ゲッター・セッターメソッド省略
    }
    
    public enum ConsentType {
        EXPLICIT,    // 明示的同意
        IMPLIED,     // 黙示的同意
        OPT_IN,      // オプトイン
        OPT_OUT      // オプトアウト
    }
}
```

### 3.3 暗号化フィールドコンバーター
```java
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, EncryptedData> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public EncryptedData convertToDatabaseColumn(String plaintext) {
        if (plaintext == null) {
            return null;
        }
        
        // アノテーションから暗号化レベル取得
        DataClassification classification = getClassificationFromContext();
        return encryptionService.encrypt(plaintext, classification);
    }
    
    @Override
    public String convertToEntityAttribute(EncryptedData encryptedData) {
        if (encryptedData == null) {
            return null;
        }
        
        return encryptionService.decrypt(encryptedData, String.class);
    }
    
    private DataClassification getClassificationFromContext() {
        // 実行コンテキストからアノテーション情報を取得
        return DataClassification.CONFIDENTIAL; // デフォルト
    }
}

@Converter
public class EncryptedEmailConverter implements AttributeConverter<EmailAddress, EncryptedData> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public EncryptedData convertToDatabaseColumn(EmailAddress email) {
        if (email == null) {
            return null;
        }
        
        return encryptionService.encrypt(email.getValue(), DataClassification.HIGHLY_CONFIDENTIAL);
    }
    
    @Override
    public EmailAddress convertToEntityAttribute(EncryptedData encryptedData) {
        if (encryptedData == null) {
            return null;
        }
        
        String decryptedEmail = encryptionService.decrypt(encryptedData, String.class);
        return new EmailAddress(decryptedEmail);
    }
}
```

## 4. Engineer集約への暗号化適用例

### 4.1 暗号化対応Engineer集約
```java
@Entity
@Table(name = "engineers")
public class Engineer extends PersonalDataEntity {
    
    @Id
    private EngineerId id;
    
    // === 個人識別情報（高度機密） ===
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true,
        processingPurposes = {"契約管理", "給与計算"},
        legalBasis = LegalBasis.CONTRACT
    )
    @Convert(converter = EncryptedStringConverter.class)
    private String fullName;
    
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true,
        processingPurposes = {"連絡業務"},
        legalBasis = LegalBasis.CONTRACT
    )
    @Convert(converter = EncryptedEmailConverter.class)
    private EmailAddress email;
    
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true
    )
    @Convert(converter = EncryptedStringConverter.class)
    private String phoneNumber;
    
    // === 検索可能な暗号化フィールド ===
    @Column(name = "name_search_hash")
    private String nameSearchHash; // 検索用ハッシュ
    
    @Column(name = "email_search_hash")
    private String emailSearchHash; // 検索用ハッシュ
    
    // === 機密情報 ===
    @PersonalData(
        classification = DataClassification.CONFIDENTIAL,
        encryptionRequired = true,
        processingPurposes = {"スキル評価", "マッチング"}
    )
    @Convert(converter = EncryptedSkillSetConverter.class)
    private SkillSet skillSet;
    
    // === 社内限定情報 ===
    @PersonalData(
        classification = DataClassification.INTERNAL,
        encryptionRequired = false,
        maskingRequired = true
    )
    private WorkStatus workStatus;
    
    /**
     * 暗号化フィールドの保存前処理
     */
    @PrePersist
    @PreUpdate
    private void generateSearchHashes() {
        if (fullName != null) {
            nameSearchHash = encryptionService.encryptForSearch(
                fullName, DataClassification.HIGHLY_CONFIDENTIAL);
        }
        if (email != null) {
            emailSearchHash = encryptionService.encryptForSearch(
                email.getValue(), DataClassification.HIGHLY_CONFIDENTIAL);
        }
        
        // アクセス記録
        recordAccess(getCurrentUserId(), "データ更新");
    }
    
    /**
     * 匿名化実装
     */
    @Override
    protected void anonymizePersonalData() {
        this.fullName = "匿名ユーザー" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
        this.email = new EmailAddress("anonymous@company.com");
        this.phoneNumber = "000-0000-0000";
        
        // スキルセットは統計的価値があるため匿名化のみ
        this.skillSet = this.skillSet.anonymize();
        
        // 検索ハッシュも更新
        generateSearchHashes();
    }
    
    /**
     * 個人データ収集
     */
    @Override
    protected Map<String, Object> collectPersonalData() {
        Map<String, Object> data = new HashMap<>();
        data.put("fullName", fullName);
        data.put("email", email != null ? email.getValue() : null);
        data.put("phoneNumber", phoneNumber);
        data.put("skillSet", skillSet);
        data.put("workStatus", workStatus);
        return data;
    }
    
    @Override
    protected String getDataSubjectId() {
        return id.getValue();
    }
    
    /**
     * マスキング表示用メソッド
     */
    public String getMaskedName() {
        return encryptionService.mask(fullName, EncryptionService.MaskingType.NAME);
    }
    
    public String getMaskedEmail() {
        return email != null ? 
            encryptionService.mask(email.getValue(), EncryptionService.MaskingType.EMAIL) : null;
    }
    
    public String getMaskedPhone() {
        return encryptionService.mask(phoneNumber, EncryptionService.MaskingType.PHONE);
    }
}
```

### 4.2 暗号化対応Repository
```java
@Repository
public interface EngineerRepository extends JpaRepository<Engineer, EngineerId> {
    
    /**
     * 暗号化ハッシュによる名前検索
     */
    @Query("SELECT e FROM Engineer e WHERE e.nameSearchHash = :nameHash")
    List<Engineer> findByNameHash(@Param("nameHash") String nameHash);
    
    /**
     * 暗号化ハッシュによるメール検索
     */
    @Query("SELECT e FROM Engineer e WHERE e.emailSearchHash = :emailHash")
    Optional<Engineer> findByEmailHash(@Param("emailHash") String emailHash);
    
    /**
     * 削除要求済みエンジニア一覧
     */
    @Query("SELECT e FROM Engineer e WHERE e.deletionRequested = true")
    List<Engineer> findDeletionRequestedEngineers();
    
    /**
     * 保持期間切れエンジニア一覧
     */
    @Query("SELECT e FROM Engineer e WHERE e.retentionManagement.expiresAt < :currentDate")
    List<Engineer> findRetentionExpiredEngineers(@Param("currentDate") LocalDateTime currentDate);
}

/**
 * 暗号化対応検索サービス
 */
@Service
public class EncryptedEngineerSearchService {
    
    private final EngineerRepository engineerRepository;
    private final EncryptionService encryptionService;
    
    /**
     * 名前による検索（暗号化対応）
     */
    public List<Engineer> searchByName(String name) {
        String nameHash = encryptionService.encryptForSearch(
            name, DataClassification.HIGHLY_CONFIDENTIAL);
        return engineerRepository.findByNameHash(nameHash);
    }
    
    /**
     * メールアドレスによる検索（暗号化対応）
     */
    public Optional<Engineer> findByEmail(String email) {
        String emailHash = encryptionService.encryptForSearch(
            email, DataClassification.HIGHLY_CONFIDENTIAL);
        return engineerRepository.findByEmailHash(emailHash);
    }
    
    /**
     * 部分マッチ検索（復号化して検索）
     * 注意: パフォーマンスが悪いため、必要な場合のみ使用
     */
    public List<Engineer> searchByNamePartial(String partialName) {
        List<Engineer> allEngineers = engineerRepository.findAll();
        
        return allEngineers.stream()
            .filter(engineer -> {
                String decryptedName = engineer.getFullName();
                return decryptedName != null && 
                       decryptedName.toLowerCase().contains(partialName.toLowerCase());
            })
            .collect(Collectors.toList());
    }
}
```

## 5. 技術スタックとの統合

### 5.1 PostgreSQL 15 透過的データ暗号化（TDE）統合
```sql
-- PostgreSQL 15 TDE設定
-- 1. 暗号化マスターキー作成
CREATE MASTER KEY ENCRYPTION BY PASSWORD 'strong_master_password';

-- 2. 列レベル暗号化の設定
CREATE TABLE engineers (
    id UUID PRIMARY KEY,
    -- 暗号化列の定義
    full_name BYTEA ENCRYPTED WITH (column_encryption_key = engineer_cek),
    email BYTEA ENCRYPTED WITH (column_encryption_key = engineer_cek),
    phone_number BYTEA ENCRYPTED WITH (column_encryption_key = engineer_cek),
    -- 検索用ハッシュ（非暗号化）
    name_search_hash VARCHAR(64),
    email_search_hash VARCHAR(64),
    -- 通常列
    work_status VARCHAR(20),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- 3. Row Level Security (RLS) によるアクセス制御
ALTER TABLE engineers ENABLE ROW LEVEL SECURITY;

CREATE POLICY engineer_access_policy ON engineers
    FOR ALL
    TO application_role
    USING (
        -- 権限チェック（Keycloakロールベース）
        current_user_has_role('ENGINEER_VIEWER') OR
        current_user_has_role('ADMIN') OR
        -- 本人のデータへのアクセス
        id = current_user_engineer_id()
    );

-- 4. パーティショニングによる保持期間管理
CREATE TABLE engineers_partitioned (
    LIKE engineers INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 年次パーティション作成
CREATE TABLE engineers_2025 PARTITION OF engineers_partitioned
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

### 5.2 Spring Boot 3.2 統合設定
```java
@Configuration
@EnableEncryptableProperties
@EnableJpaAuditing
public class DataProtectionConfiguration {
    
    /**
     * Spring Boot 3.2 暗号化プロパティ設定
     */
    @Bean
    public StringEncryptor stringEncryptor() {
        PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
        SimpleStringPBEConfig config = new SimpleStringPBEConfig();
        config.setPassword(System.getenv("JASYPT_ENCRYPTOR_PASSWORD"));
        config.setAlgorithm("PBEWITHHMACSHA512ANDAES_256");
        config.setKeyObtentionIterations("1000");
        config.setPoolSize("1");
        config.setSaltGeneratorClassName("org.jasypt.salt.RandomSaltGenerator");
        config.setIvGeneratorClassName("org.jasypt.iv.RandomIvGenerator");
        config.setStringOutputType("base64");
        encryptor.setConfig(config);
        return encryptor;
    }
    
    /**
     * PostgreSQL TDE対応DataSource設定
     */
    @Bean
    @ConfigurationProperties("spring.datasource")
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        
        // TDE用の接続プロパティ
        Properties props = new Properties();
        props.setProperty("ssl", "true");
        props.setProperty("sslmode", "require");
        props.setProperty("column_encryption", "true");
        props.setProperty("column_master_key", System.getenv("PG_COLUMN_MASTER_KEY"));
        
        dataSource.setDataSourceProperties(props);
        return dataSource;
    }
    
    /**
     * Spring Boot Actuator暗号化メトリクス
     */
    @Component
    public class EncryptionMetrics {
        private final MeterRegistry meterRegistry;
        private final Counter encryptionCounter;
        private final Counter decryptionCounter;
        private final Timer encryptionTimer;
        
        public EncryptionMetrics(MeterRegistry meterRegistry) {
            this.meterRegistry = meterRegistry;
            this.encryptionCounter = Counter.builder("data.encryption.count")
                .description("Number of encryption operations")
                .register(meterRegistry);
            this.decryptionCounter = Counter.builder("data.decryption.count")
                .description("Number of decryption operations")
                .register(meterRegistry);
            this.encryptionTimer = Timer.builder("data.encryption.duration")
                .description("Encryption operation duration")
                .register(meterRegistry);
        }
        
        public void recordEncryption(Runnable operation) {
            encryptionTimer.record(operation);
            encryptionCounter.increment();
        }
        
        public void recordDecryption() {
            decryptionCounter.increment();
        }
    }
    
    /**
     * 暗号化ヘルスインジケータ
     */
    @Component
    public class EncryptionHealthIndicator implements HealthIndicator {
        private final EncryptionService encryptionService;
        private final KeyManagementService keyManagementService;
        
        @Override
        public Health health() {
            try {
                // 暗号化サービスの状態チェック
                boolean encryptionHealthy = encryptionService.isHealthy();
                
                // キー管理サービスの状態チェック
                boolean kmsHealthy = keyManagementService.isHealthy();
                
                // キーローテーション状況
                Map<String, Object> details = new HashMap<>();
                details.put("encryptionService", encryptionHealthy ? "UP" : "DOWN");
                details.put("keyManagementService", kmsHealthy ? "UP" : "DOWN");
                details.put("lastKeyRotation", keyManagementService.getLastRotationTime());
                details.put("nextKeyRotation", keyManagementService.getNextRotationTime());
                
                if (encryptionHealthy && kmsHealthy) {
                    return Health.up().withDetails(details).build();
                } else {
                    return Health.down().withDetails(details).build();
                }
            } catch (Exception e) {
                return Health.down().withException(e).build();
            }
        }
    }
}
```

### 5.3 Keycloak統合セキュリティ
```java
@Component
public class KeycloakEncryptionIntegration {
    
    private final KeycloakSecurityContext keycloakSecurityContext;
    private final EncryptionService encryptionService;
    private final KeyManagementService keyManagementService;
    
    /**
     * ユーザー権限に基づく暗号化キーアクセス制御
     */
    public EncryptionKey getEncryptionKeyForUser(DataClassification classification) {
        // Keycloakトークンから権限取得
        Set<String> roles = keycloakSecurityContext.getToken().getRealmAccess().getRoles();
        
        // ロールに基づくキーアクセス権限チェック
        if (!hasKeyAccessPermission(roles, classification)) {
            throw new SecurityException("Insufficient permissions for encryption key access");
        }
        
        // ユーザーコンテキストを含むキー取得
        String userId = keycloakSecurityContext.getToken().getSubject();
        return keyManagementService.getKeyWithUserContext(classification, userId);
    }
    
    /**
     * 復号化権限チェック
     */
    public boolean canDecrypt(EncryptedData data) {
        Set<String> roles = keycloakSecurityContext.getToken().getRealmAccess().getRoles();
        DataClassification classification = getClassificationFromKeyId(data.getKeyId());
        
        // 特権ロールチェック
        if (roles.contains("ADMIN") || roles.contains("DATA_PROTECTION_OFFICER")) {
            return true;
        }
        
        // データ所有者チェック
        if (isDataOwner(data)) {
            return true;
        }
        
        // ロールベースアクセス制御
        return hasDecryptPermission(roles, classification);
    }
    
    /**
     * Keycloakイベントと監査ログの統合
     */
    @EventListener
    public void handleKeycloakEvent(KeycloakAuthenticationEvent event) {
        if (event.getType() == EventType.LOGIN) {
            // ログイン時の暗号化キー初期化
            initializeUserEncryptionContext(event.getUserId());
        } else if (event.getType() == EventType.LOGOUT) {
            // ログアウト時の暗号化コンテキストクリア
            clearUserEncryptionContext(event.getUserId());
        }
    }
    
    /**
     * トークンベース暗号化キー導出
     */
    public SecretKey deriveEncryptionKey(String purpose) {
        // Keycloakトークンを暗号化キー導出に使用
        String token = keycloakSecurityContext.getTokenString();
        String userId = keycloakSecurityContext.getToken().getSubject();
        
        // HKDF (HMAC-based Key Derivation Function) を使用
        byte[] salt = (userId + purpose).getBytes(StandardCharsets.UTF_8);
        HKDFBytesGenerator hkdf = new HKDFBytesGenerator(new HMac(new SHA256Digest()));
        hkdf.init(new HKDFParameters(token.getBytes(), salt, purpose.getBytes()));
        
        byte[] keyBytes = new byte[32]; // 256 bits
        hkdf.generateBytes(keyBytes, 0, keyBytes.length);
        
        return new SecretKeySpec(keyBytes, "AES");
    }
    
    private boolean hasKeyAccessPermission(Set<String> roles, DataClassification classification) {
        switch (classification) {
            case HIGHLY_CONFIDENTIAL:
                return roles.contains("ADMIN") || roles.contains("DATA_PROTECTION_OFFICER");
            case CONFIDENTIAL:
                return roles.contains("MANAGER") || roles.contains("ADMIN");
            case INTERNAL:
                return roles.contains("EMPLOYEE") || roles.contains("MANAGER") || roles.contains("ADMIN");
            case PUBLIC:
                return true;
            default:
                return false;
        }
    }
}

/**
 * Keycloak認証フィルタでの暗号化コンテキスト設定
 */
@Component
public class EncryptionContextFilter extends OncePerRequestFilter {
    
    private final KeycloakSecurityContext keycloakSecurityContext;
    private final EncryptionContextHolder encryptionContextHolder;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        try {
            // Keycloak認証情報から暗号化コンテキスト設定
            if (keycloakSecurityContext != null && keycloakSecurityContext.getToken() != null) {
                EncryptionContext context = new EncryptionContext();
                context.setUserId(keycloakSecurityContext.getToken().getSubject());
                context.setRoles(keycloakSecurityContext.getToken().getRealmAccess().getRoles());
                context.setSessionId(request.getSession().getId());
                
                encryptionContextHolder.setContext(context);
            }
            
            filterChain.doFilter(request, response);
            
        } finally {
            // リクエスト終了時にコンテキストクリア
            encryptionContextHolder.clearContext();
        }
    }
}
```

## 6. Redis暗号化キャッシュ戦略

### 6.1 Redis暗号化キャッシュアーキテクチャ
```java
@Configuration
@EnableCaching
public class RedisEncryptionCacheConfiguration {
    
    /**
     * 暗号化対応 Redisテンプレート
     */
    @Bean
    public RedisTemplate<String, EncryptedCacheData> encryptedRedisTemplate(
            RedisConnectionFactory connectionFactory,
            EncryptionService encryptionService) {
        
        RedisTemplate<String, EncryptedCacheData> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // カスタムシリアライザ設定
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new EncryptedCacheDataSerializer(encryptionService));
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new EncryptedCacheDataSerializer(encryptionService));
        
        return template;
    }
    
    /**
     * 暗号化キャッシュマネージャ
     */
    @Bean
    public CacheManager encryptedCacheManager(
            RedisConnectionFactory connectionFactory,
            EncryptionService encryptionService) {
        
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new EncryptedCacheDataSerializer(encryptionService)))
            .entryTtl(Duration.ofMinutes(15)) // デフォルトTTL
            .disableCachingNullValues();
        
        // キャッシュ別設定
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        
        // 個人情報キャッシュ（短いTTL）
        cacheConfigurations.put("personalData", config.entryTtl(Duration.ofMinutes(5)));
        
        // 機密情報キャッシュ（非常に短いTTL）
        cacheConfigurations.put("confidentialData", config.entryTtl(Duration.ofMinutes(1)));
        
        // 検索ハッシュキャッシュ（長いTTL）
        cacheConfigurations.put("searchHash", config.entryTtl(Duration.ofHours(1)));
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .withInitialCacheConfigurations(cacheConfigurations)
            .build();
    }
}

/**
 * 暗号化キャッシュデータ
 */
@Data
public class EncryptedCacheData implements Serializable {
    private String encryptedData;      // 暗号化済みデータ
    private String iv;                 // 初期化ベクトル
    private String keyId;              // 暗号化キーID
    private Instant cachedAt;          // キャッシュ日時
    private String dataChecksum;       // データ整合性チェックサム
    private DataClassification classification; // データ分類
}

/**
 * 暗号化キャッシュサービス
 */
@Service
public class EncryptedCacheService {
    
    private final RedisTemplate<String, EncryptedCacheData> redisTemplate;
    private final EncryptionService encryptionService;
    private final EncryptionMetrics encryptionMetrics;
    
    /**
     * 暗号化してキャッシュ保存
     */
    @Cacheable(value = "personalData", key = "#key", condition = "#cacheable")
    public <T> T cacheEncrypted(String key, T data, DataClassification classification, boolean cacheable) {
        if (!cacheable || !shouldCache(classification)) {
            return data;
        }
        
        try {
            // 暗号化
            EncryptedData encrypted = encryptionService.encrypt(data, classification);
            
            // キャッシュデータ作成
            EncryptedCacheData cacheData = new EncryptedCacheData();
            cacheData.setEncryptedData(encrypted.getData());
            cacheData.setIv(encrypted.getIv());
            cacheData.setKeyId(encrypted.getKeyId());
            cacheData.setCachedAt(Instant.now());
            cacheData.setDataChecksum(calculateChecksum(data));
            cacheData.setClassification(classification);
            
            // TTL設定
            Duration ttl = getTTLForClassification(classification);
            redisTemplate.opsForValue().set(key, cacheData, ttl);
            
            // メトリクス記録
            encryptionMetrics.recordCacheEncryption();
            
            return data;
            
        } catch (Exception e) {
            log.error("Failed to cache encrypted data", e);
            return data; // キャッシュ失敗時は元データを返す
        }
    }
    
    /**
     * キャッシュから復号化して取得
     */
    public <T> Optional<T> getDecrypted(String key, Class<T> type) {
        try {
            EncryptedCacheData cacheData = redisTemplate.opsForValue().get(key);
            if (cacheData == null) {
                return Optional.empty();
            }
            
            // キャッシュ有効性チェック
            if (!isValidCache(cacheData)) {
                redisTemplate.delete(key);
                return Optional.empty();
            }
            
            // 復号化
            EncryptedData encrypted = new EncryptedData(
                cacheData.getEncryptedData(),
                cacheData.getIv(),
                cacheData.getKeyId(),
                cacheData.getCachedAt()
            );
            
            T decrypted = encryptionService.decrypt(encrypted, type);
            
            // データ整合性チェック
            if (!verifyChecksum(decrypted, cacheData.getDataChecksum())) {
                log.warn("Cache data integrity check failed for key: {}", key);
                redisTemplate.delete(key);
                return Optional.empty();
            }
            
            // メトリクス記録
            encryptionMetrics.recordCacheDecryption();
            
            return Optional.of(decrypted);
            
        } catch (Exception e) {
            log.error("Failed to get decrypted data from cache", e);
            return Optional.empty();
        }
    }
    
    /**
     * 検索ハッシュキャッシュ
     */
    @Cacheable(value = "searchHash", key = "#plaintext + ':' + #classification")
    public String cacheSearchHash(String plaintext, DataClassification classification) {
        return encryptionService.encryptForSearch(plaintext, classification);
    }
    
    /**
     * セッションベース暗号化キー管理
     */
    public void storeSessionKey(String sessionId, SecretKey key, Duration ttl) {
        // セッションキーを暗号化して保存
        EncryptedData encryptedKey = encryptionService.encrypt(
            Base64.getEncoder().encodeToString(key.getEncoded()),
            DataClassification.HIGHLY_CONFIDENTIAL
        );
        
        String redisKey = "session:key:" + sessionId;
        redisTemplate.opsForValue().set(redisKey, encryptedKey, ttl);
    }
    
    public Optional<SecretKey> getSessionKey(String sessionId) {
        String redisKey = "session:key:" + sessionId;
        EncryptedCacheData cacheData = redisTemplate.opsForValue().get(redisKey);
        
        if (cacheData == null) {
            return Optional.empty();
        }
        
        try {
            String keyString = encryptionService.decrypt(
                new EncryptedData(
                    cacheData.getEncryptedData(),
                    cacheData.getIv(),
                    cacheData.getKeyId(),
                    cacheData.getCachedAt()
                ),
                String.class
            );
            
            byte[] keyBytes = Base64.getDecoder().decode(keyString);
            return Optional.of(new SecretKeySpec(keyBytes, "AES"));
            
        } catch (Exception e) {
            log.error("Failed to retrieve session key", e);
            return Optional.empty();
        }
    }
    
    /**
     * キャッシュ無効化
     */
    @CacheEvict(value = {"personalData", "confidentialData", "searchHash"}, key = "#key")
    public void evictEncrypted(String key) {
        log.info("Evicting encrypted cache for key: {}", key);
    }
    
    /**
     * ユーザー全キャッシュクリア（GDPR対応）
     */
    public void clearUserCache(String userId) {
        Set<String> keys = redisTemplate.keys("*:" + userId + ":*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
            log.info("Cleared {} cache entries for user: {}", keys.size(), userId);
        }
    }
    
    private Duration getTTLForClassification(DataClassification classification) {
        switch (classification) {
            case HIGHLY_CONFIDENTIAL:
                return Duration.ofMinutes(1);
            case CONFIDENTIAL:
                return Duration.ofMinutes(5);
            case INTERNAL:
                return Duration.ofMinutes(15);
            case PUBLIC:
                return Duration.ofHours(1);
            default:
                return Duration.ofMinutes(5);
        }
    }
    
    private boolean shouldCache(DataClassification classification) {
        // 極秘情報は基本的にキャッシュしない
        // ただし、特定の条件下では許可
        return classification != DataClassification.HIGHLY_CONFIDENTIAL || 
               isHighSecurityCacheEnabled();
    }
    
    private boolean isValidCache(EncryptedCacheData cacheData) {
        // キーローテーションチェック
        if (!keyManagementService.isKeyValid(cacheData.getKeyId())) {
            return false;
        }
        
        // キャッシュ期限チェック
        Duration maxAge = getTTLForClassification(cacheData.getClassification());
        if (cacheData.getCachedAt().plus(maxAge).isBefore(Instant.now())) {
            return false;
        }
        
        return true;
    }
    
    private String calculateChecksum(Object data) {
        try {
            String json = objectMapper.writeValueAsString(data);
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(json.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException("Failed to calculate checksum", e);
        }
    }
    
    private boolean verifyChecksum(Object data, String expectedChecksum) {
        String actualChecksum = calculateChecksum(data);
        return MessageDigest.isEqual(
            actualChecksum.getBytes(StandardCharsets.UTF_8),
            expectedChecksum.getBytes(StandardCharsets.UTF_8)
        );
    }
}

/**
 * Redis暗号化監視
 */
@Component
public class RedisEncryptionMonitor {
    
    private final RedisTemplate<String, EncryptedCacheData> redisTemplate;
    private final MeterRegistry meterRegistry;
    
    @Scheduled(fixedDelay = 60000) // 1分ごと
    public void monitorEncryptedCache() {
        // キャッシュ統計
        Set<String> allKeys = redisTemplate.keys("*");
        if (allKeys != null) {
            Map<DataClassification, Long> classificationCounts = new HashMap<>();
            
            for (String key : allKeys) {
                EncryptedCacheData data = redisTemplate.opsForValue().get(key);
                if (data != null) {
                    classificationCounts.merge(data.getClassification(), 1L, Long::sum);
                }
            }
            
            // メトリクス更新
            classificationCounts.forEach((classification, count) -> {
                meterRegistry.gauge("cache.encrypted.count",
                    Tags.of("classification", classification.name()),
                    count);
            });
        }
        
        // 期限切れキーの検出と削除
        cleanupExpiredKeys();
    }
    
    private void cleanupExpiredKeys() {
        // 期限切れキーの自動削除ロジック
    }
}
```

## 7. 外部サービス連携セキュリティ

### 7.1 CloudSign連携セキュリティ
```java
@Component
public class CloudSignSecurityService {
    
    private final EncryptionService encryptionService;
    private final KeyManagementService keyManagementService;
    private final AuditService auditService;
    
    /**
     * CloudSign APIキー管理
     */
    @Value("${cloudsign.api.key.encrypted}")
    private String encryptedApiKey;
    
    @Value("${cloudsign.api.secret.encrypted}")
    private String encryptedApiSecret;
    
    /**
     * APIキーの復号化
     */
    public CloudSignCredentials getDecryptedCredentials() {
        try {
            // マスターキーで復号化
            String apiKey = encryptionService.decrypt(
                parseEncryptedValue(encryptedApiKey),
                String.class
            );
            String apiSecret = encryptionService.decrypt(
                parseEncryptedValue(encryptedApiSecret),
                String.class
            );
            
            // アクセスログ
            auditService.logExternalApiAccess("CloudSign", "API Key Retrieved");
            
            return new CloudSignCredentials(apiKey, apiSecret);
            
        } catch (Exception e) {
            auditService.logSecurityIncident("CloudSign API key decryption failed", e);
            throw new SecurityException("Failed to retrieve CloudSign credentials", e);
        }
    }
    
    /**
     * 送信データの暗号化
     */
    public String encryptContractData(ContractDocument document) {
        // 個人情報を含む契約データの暗号化
        Map<String, Object> sanitizedData = new HashMap<>();
        
        // 個人情報のマスキング
        sanitizedData.put("contractorName", 
            encryptionService.mask(document.getContractorName(), MaskingType.NAME));
        sanitizedData.put("contractorEmail", 
            encryptionService.mask(document.getContractorEmail(), MaskingType.EMAIL));
        
        // 機密情報の暗号化
        EncryptedData encryptedAmount = encryptionService.encrypt(
            document.getContractAmount(),
            DataClassification.CONFIDENTIAL
        );
        sanitizedData.put("contractAmount", encryptedAmount);
        
        // 署名用URLの一時的な保存
        String temporaryId = UUID.randomUUID().toString();
        cacheService.cacheEncrypted(
            "cloudsign:contract:" + temporaryId,
            sanitizedData,
            DataClassification.CONFIDENTIAL,
            true
        );
        
        return temporaryId;
    }
    
    /**
     * 署名完了データの受信処理
     */
    public void processSignedDocument(String documentId, byte[] signedPdf) {
        try {
            // PDFの暗号化保存
            EncryptedData encryptedPdf = encryptionService.encrypt(
                Base64.getEncoder().encodeToString(signedPdf),
                DataClassification.CONFIDENTIAL
            );
            
            // デジタル署名の検証
            boolean isValid = verifyDigitalSignature(signedPdf);
            if (!isValid) {
                auditService.logSecurityIncident(
                    "Invalid digital signature detected for document: " + documentId,
                    null
                );
                throw new SecurityException("Invalid digital signature");
            }
            
            // 保存
            contractRepository.saveEncryptedDocument(documentId, encryptedPdf);
            
            // 一時データの削除
            cacheService.evictEncrypted("cloudsign:contract:" + documentId);
            
        } catch (Exception e) {
            auditService.logSecurityIncident(
                "Failed to process signed document: " + documentId,
                e
            );
            throw new SecurityException("Document processing failed", e);
        }
    }
    
    /**
     * Webhookセキュリティ
     */
    public boolean verifyWebhookSignature(String payload, String signature) {
        try {
            // HMAC-SHA256で署名検証
            CloudSignCredentials credentials = getDecryptedCredentials();
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKey = new SecretKeySpec(
                credentials.getApiSecret().getBytes(StandardCharsets.UTF_8),
                "HmacSHA256"
            );
            mac.init(secretKey);
            
            byte[] calculatedSignature = mac.doFinal(
                payload.getBytes(StandardCharsets.UTF_8)
            );
            String calculatedSignatureBase64 = Base64.getEncoder()
                .encodeToString(calculatedSignature);
            
            boolean isValid = MessageDigest.isEqual(
                signature.getBytes(StandardCharsets.UTF_8),
                calculatedSignatureBase64.getBytes(StandardCharsets.UTF_8)
            );
            
            if (!isValid) {
                auditService.logSecurityIncident(
                    "CloudSign webhook signature verification failed",
                    null
                );
            }
            
            return isValid;
            
        } catch (Exception e) {
            auditService.logSecurityIncident(
                "CloudSign webhook verification error",
                e
            );
            return false;
        }
    }
}
```

### 7.2 MoneyForward連携セキュリティ
```java
@Component
public class MoneyForwardSecurityService {
    
    private final EncryptionService encryptionService;
    private final OAuth2Service oauth2Service;
    private final TokenStorageService tokenStorageService;
    
    /**
     * OAuth2トークンの安全な保存
     */
    public void storeOAuth2Tokens(OAuth2TokenResponse tokenResponse) {
        try {
            // アクセストークンの暗号化
            EncryptedData encryptedAccessToken = encryptionService.encrypt(
                tokenResponse.getAccessToken(),
                DataClassification.HIGHLY_CONFIDENTIAL
            );
            
            // リフレッシュトークンの暗号化
            EncryptedData encryptedRefreshToken = encryptionService.encrypt(
                tokenResponse.getRefreshToken(),
                DataClassification.HIGHLY_CONFIDENTIAL
            );
            
            // 暗号化トークンの保存
            OAuth2TokenStore tokenStore = new OAuth2TokenStore();
            tokenStore.setAccessToken(encryptedAccessToken);
            tokenStore.setRefreshToken(encryptedRefreshToken);
            tokenStore.setExpiresAt(tokenResponse.getExpiresAt());
            tokenStore.setScope(tokenResponse.getScope());
            
            tokenStorageService.save(tokenStore);
            
            // 監査ログ
            auditService.logExternalApiAccess(
                "MoneyForward",
                "OAuth2 tokens stored"
            );
            
        } catch (Exception e) {
            auditService.logSecurityIncident(
                "Failed to store MoneyForward OAuth2 tokens",
                e
            );
            throw new SecurityException("Token storage failed", e);
        }
    }
    
    /**
     * APIリクエストのセキュアな実行
     */
    public <T> T executeSecureApiRequest(
            String endpoint,
            HttpMethod method,
            Object requestBody,
            Class<T> responseType) {
        
        try {
            // トークン取得と復号化
            OAuth2TokenStore tokenStore = tokenStorageService.getCurrentToken();
            String accessToken = encryptionService.decrypt(
                tokenStore.getAccessToken(),
                String.class
            );
            
            // トークンの有効性チェック
            if (tokenStore.isExpired()) {
                accessToken = refreshAccessToken(tokenStore);
            }
            
            // リクエストボディのサニタイズ
            Object sanitizedBody = sanitizeRequestBody(requestBody);
            
            // HTTPSリクエスト実行
            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(accessToken);
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            HttpEntity<Object> entity = new HttpEntity<>(sanitizedBody, headers);
            
            ResponseEntity<T> response = restTemplate.exchange(
                endpoint,
                method,
                entity,
                responseType
            );
            
            // レスポンスの検証
            validateApiResponse(response);
            
            // 機密データの暗号化保存
            if (containsSensitiveData(response.getBody())) {
                encryptAndStoreSensitiveData(response.getBody());
            }
            
            return response.getBody();
            
        } catch (Exception e) {
            auditService.logSecurityIncident(
                "MoneyForward API request failed: " + endpoint,
                e
            );
            throw new ExternalServiceException("API request failed", e);
        }
    }
    
    /**
     * 財務データの暗号化処理
     */
    public void processFinancialData(FinancialDataResponse data) {
        // 銀行口座情報の暗号化
        if (data.getBankAccounts() != null) {
            data.getBankAccounts().forEach(account -> {
                // 口座番号の暗号化
                EncryptedData encryptedAccountNumber = encryptionService.encrypt(
                    account.getAccountNumber(),
                    DataClassification.HIGHLY_CONFIDENTIAL
                );
                account.setEncryptedAccountNumber(encryptedAccountNumber);
                account.setAccountNumber(null); // 平文を削除
                
                // 口座名義のマスキング
                account.setMaskedAccountName(
                    encryptionService.mask(
                        account.getAccountName(),
                        MaskingType.NAME
                    )
                );
            });
        }
        
        // 取引情報の暗号化
        if (data.getTransactions() != null) {
            data.getTransactions().forEach(transaction -> {
                // 金額情報の暗号化
                EncryptedData encryptedAmount = encryptionService.encrypt(
                    transaction.getAmount(),
                    DataClassification.CONFIDENTIAL
                );
                transaction.setEncryptedAmount(encryptedAmount);
                transaction.setAmount(null);
                
                // 取引先情報のマスキング
                transaction.setMaskedCounterparty(
                    encryptionService.mask(
                        transaction.getCounterparty(),
                        MaskingType.PARTIAL
                    )
                );
            });
        }
        
        // 暗号化データの保存
        financialDataRepository.saveEncrypted(data);
    }
    
    /**
     * データ同期セキュリティ
     */
    @Scheduled(cron = "0 0 3 * * ?")
    public void syncFinancialDataSecurely() {
        try {
            // 夜間バッチでの安全なデータ同期
            log.info("Starting secure financial data sync");
            
            // APIレート制限対策
            RateLimiter rateLimiter = RateLimiter.create(2.0); // 2 requests per second
            
            // ページネーションでデータ取得
            String nextPageToken = null;
            do {
                rateLimiter.acquire();
                
                FinancialDataPage page = executeSecureApiRequest(
                    "/api/v1/transactions?page_token=" + nextPageToken,
                    HttpMethod.GET,
                    null,
                    FinancialDataPage.class
                );
                
                // 各ページのデータを暗号化処理
                processFinancialData(page.getData());
                
                nextPageToken = page.getNextPageToken();
                
            } while (nextPageToken != null);
            
            log.info("Financial data sync completed successfully");
            
        } catch (Exception e) {
            auditService.logSecurityIncident(
                "Financial data sync failed",
                e
            );
            // アラート送信
            alertService.sendSecurityAlert(
                "MoneyForward sync failure",
                e.getMessage()
            );
        }
    }
    
    private String refreshAccessToken(OAuth2TokenStore tokenStore) {
        // リフレッシュトークンを使用して新しいアクセストークン取得
        String refreshToken = encryptionService.decrypt(
            tokenStore.getRefreshToken(),
            String.class
        );
        
        OAuth2TokenResponse newTokens = oauth2Service.refreshToken(refreshToken);
        storeOAuth2Tokens(newTokens);
        
        return newTokens.getAccessToken();
    }
    
    private Object sanitizeRequestBody(Object requestBody) {
        // リクエストボディから機密情報を除去
        if (requestBody == null) return null;
        
        // ディープコピーを作成し、機密フィールドをマスク
        return sanitizer.sanitize(requestBody);
    }
    
    private void validateApiResponse(ResponseEntity<?> response) {
        // レスポンスの安全性検証
        if (!response.getStatusCode().is2xxSuccessful()) {
            throw new ExternalServiceException(
                "API returned error: " + response.getStatusCode()
            );
        }
        
        // Content-Type検証
        MediaType contentType = response.getHeaders().getContentType();
        if (contentType == null || !contentType.includes(MediaType.APPLICATION_JSON)) {
            throw new SecurityException("Unexpected content type: " + contentType);
        }
    }
}
```

### 7.3 外部サービス連携共通セキュリティ
```java
@Component
public class ExternalServiceSecurityConfig {
    
    /**
     * 外部API通信用RestTemplate設定
     */
    @Bean
    public RestTemplate secureRestTemplate() {
        RestTemplate restTemplate = new RestTemplate();
        
        // SSL/TLS設定
        HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> {
            // ホスト名検証
            return isValidExternalHost(hostname);
        });
        
        // タイムアウト設定
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(10000); // 10秒
        factory.setReadTimeout(30000);    // 30秒
        
        restTemplate.setRequestFactory(factory);
        
        // インターセプター追加
        restTemplate.getInterceptors().add(new SecurityHeadersInterceptor());
        restTemplate.getInterceptors().add(new RequestLoggingInterceptor());
        
        return restTemplate;
    }
    
    /**
     * セキュリティヘッダーインターセプター
     */
    private static class SecurityHeadersInterceptor implements ClientHttpRequestInterceptor {
        @Override
        public ClientHttpResponse intercept(
                HttpRequest request,
                byte[] body,
                ClientHttpRequestExecution execution) throws IOException {
            
            // セキュリティヘッダー追加
            request.getHeaders().add("X-Request-ID", UUID.randomUUID().toString());
            request.getHeaders().add("User-Agent", "SES-Manager/1.0");
            
            return execution.execute(request, body);
        }
    }
    
    /**
     * APIキーローテーションスケジューラ
     */
    @Scheduled(cron = "0 0 0 1 * ?")
    public void rotateExternalApiKeys() {
        log.info("Starting external API key rotation");
        
        try {
            // CloudSign APIキーローテーション
            rotateCloudSignApiKey();
            
            // MoneyForward OAuthトークン更新
            refreshMoneyForwardTokens();
            
            log.info("API key rotation completed successfully");
            
        } catch (Exception e) {
            alertService.sendSecurityAlert(
                "API key rotation failed",
                e.getMessage()
            );
        }
    }
    
    private boolean isValidExternalHost(String hostname) {
        // ホワイトリストに基づく検証
        List<String> allowedHosts = Arrays.asList(
            "api.cloudsign.jp",
            "api.moneyforward.com",
            "*.cloudsign.jp",
            "*.moneyforward.com"
        );
        
        return allowedHosts.stream()
            .anyMatch(pattern -> matchesPattern(hostname, pattern));
    }
}
```

## 8. データ保護運用

### 8.1 定期クリーンアップジョブ
```java
@Component
public class DataProtectionScheduler {
    
    private final EngineerRepository engineerRepository;
    private final DataDeletionService dataDeletionService;
    
    /**
     * 保持期間切れデータの自動削除
     */
    @Scheduled(cron = "0 0 2 * * ?") // 毎日2時実行
    public void cleanupRetentionExpiredData() {
        LocalDateTime currentDate = LocalDateTime.now();
        List<Engineer> expiredEngineers = engineerRepository.findRetentionExpiredEngineers(currentDate);
        
        for (Engineer engineer : expiredEngineers) {
            if (engineer.canBeDeleted()) {
                dataDeletionService.safeDelete(engineer);
            } else {
                engineer.anonymize();
                engineerRepository.save(engineer);
            }
        }
    }
    
    /**
     * 削除要求処理
     */
    @Scheduled(cron = "0 30 2 * * ?") // 毎日2:30実行
    public void processDeletionRequests() {
        List<Engineer> deletionRequested = engineerRepository.findDeletionRequestedEngineers();
        
        for (Engineer engineer : deletionRequested) {
            dataDeletionService.processGDPRDeletion(engineer);
        }
    }
}
```

### 8.2 データ保護監査サービス
```java
@Service
public class DataProtectionAuditService {
    
    /**
     * GDPR準拠監査
     */
    public GDPRAuditReport generateGDPRAuditReport() {
        GDPRAuditReport report = new GDPRAuditReport();
        
        // 個人データ処理活動の記録
        report.setProcessingActivities(auditProcessingActivities());
        
        // 同意管理状況
        report.setConsentManagement(auditConsentManagement());
        
        // データ保護影響評価
        report.setDPIA(auditDataProtectionImpact());
        
        // セキュリティ措置
        report.setSecurityMeasures(auditSecurityMeasures());
        
        return report;
    }
    
    /**
     * データブリーチ検知
     */
    public void detectDataBreach() {
        // 異常なデータアクセスパターンの検知
        // 大量データ抽出の検知
        // 不正なデータ変更の検知
    }
}
```

## 9. 実装ガイドライン

### 9.1 開発環境でのデータ保護
```yaml
# application-dev.yml
spring:
  profiles:
    active: dev
  
# 開発環境用暗号化設定
encryption:
  mode: development
  # 開発環境では擬似暗号化を使用
  use-mock: true
  # 本番データの自動マスキング
  auto-mask-production-data: true
  
# 開発用データベース
datasource:
  # 本番データのコピー時に自動化名化
  anonymize-on-import: true
  # テストデータ生成
  generate-test-data: true
```

```java
@Profile("dev")
@Component
public class DevelopmentDataProtection {
    
    /**
     * 開発環境用データマスキング
     */
    @EventListener(ApplicationReadyEvent.class)
    public void setupDevelopmentEnvironment() {
        log.info("Setting up development data protection");
        
        // 本番データの自動検出とマスキング
        maskProductionData();
        
        // テストデータ生成
        generateSafeTestData();
    }
    
    /**
     * 本番データの自動マスキング
     */
    private void maskProductionData() {
        // 個人情報を含むテーブルの自動検出
        List<String> personalDataTables = Arrays.asList(
            "engineers", "users", "contracts", "billing_info"
        );
        
        personalDataTables.forEach(table -> {
            String maskQuery = String.format(
                "UPDATE %s SET " +
                "full_name = 'Test User ' || id, " +
                "email = 'test' || id || '@example.com', " +
                "phone_number = '090-0000-' || LPAD(CAST(id AS TEXT), 4, '0') " +
                "WHERE full_name NOT LIKE 'Test%%'",
                table
            );
            
            jdbcTemplate.execute(maskQuery);
            log.info("Masked production data in table: {}", table);
        });
    }
    
    /**
     * テストデータ生成
     */
    private void generateSafeTestData() {
        TestDataGenerator generator = new TestDataGenerator();
        
        // エンジニアテストデータ
        for (int i = 1; i <= 10; i++) {
            Engineer testEngineer = generator.createTestEngineer(
                "Test Engineer " + i,
                "test.engineer" + i + "@example.com",
                "090-0000-000" + i
            );
            engineerRepository.save(testEngineer);
        }
        
        log.info("Generated test data for development environment");
    }
}
```

### 9.2 エンティティ実装ガイドライン
```java
/**
 * データ保護対応エンティティの実装例
 */
@Entity
public class SampleProtectedEntity extends PersonalDataEntity {
    
    // === ステップ1: データ分類の指定 ===
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true,
        retentionYears = 7,
        processingPurposes = {"本人確認", "連絡業務"},
        legalBasis = LegalBasis.CONTRACT
    )
    @Convert(converter = EncryptedStringConverter.class)
    private String sensitiveData;
    
    // === ステップ2: 検索用ハッシュフィールド ===
    @Column(name = "sensitive_data_hash")
    private String sensitiveDataHash;
    
    // === ステップ3: マスキング用メソッド ===
    public String getMaskedSensitiveData() {
        return encryptionService.mask(sensitiveData, MaskingType.PARTIAL);
    }
    
    // === ステップ4: 検索ハッシュ生成 ===
    @PrePersist
    @PreUpdate
    private void generateSearchHash() {
        if (sensitiveData != null) {
            this.sensitiveDataHash = encryptionService.encryptForSearch(
                sensitiveData, 
                DataClassification.HIGHLY_CONFIDENTIAL
            );
        }
    }
    
    // === ステップ5: 抽象メソッド実装 ===
    @Override
    protected String getDataSubjectId() {
        return this.id.toString();
    }
    
    @Override
    protected void anonymizePersonalData() {
        this.sensitiveData = "ANONYMIZED_" + UUID.randomUUID();
        generateSearchHash();
    }
    
    @Override
    protected Map<String, Object> collectPersonalData() {
        Map<String, Object> data = new HashMap<>();
        data.put("sensitiveData", this.sensitiveData);
        return data;
    }
}
```

### 9.3 API実装ガイドライン
```java
@RestController
@RequestMapping("/api/v1/protected")
public class DataProtectedController {
    
    private final EncryptedSearchService searchService;
    private final DataProtectionService protectionService;
    
    /**
     * 暗号化データの検索API
     */
    @GetMapping("/search")
    @PreAuthorize("hasRole('DATA_VIEWER')")
    public ResponseEntity<List<ProtectedDataDto>> search(
            @RequestParam String query,
            @AuthenticationPrincipal UserDetails user) {
        
        // 監査ログ
        auditService.logDataAccess(user.getUsername(), "SEARCH", query);
        
        // 暗号化検索
        List<ProtectedEntity> results = searchService.searchEncrypted(query);
        
        // マスキングして返却
        List<ProtectedDataDto> dtos = results.stream()
            .map(entity -> toMaskedDto(entity, user))
            .collect(Collectors.toList());
        
        return ResponseEntity.ok(dtos);
    }
    
    /**
     * GDPR権利行使API
     */
    @PostMapping("/gdpr/delete-request")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Void> requestDeletion(
            @RequestBody DeletionRequest request,
            @AuthenticationPrincipal UserDetails user) {
        
        // 本人確認
        if (!verifyIdentity(request.getDataSubjectId(), user)) {
            throw new SecurityException("Identity verification failed");
        }
        
        // 削除要求処理
        protectionService.processDeletionRequest(
            request.getDataSubjectId(),
            request.getReason(),
            user.getUsername()
        );
        
        return ResponseEntity.accepted().build();
    }
    
    /**
     * データエクスポートAPI
     */
    @GetMapping("/gdpr/export")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<PersonalDataExport> exportData(
            @AuthenticationPrincipal UserDetails user) {
        
        // 本人のデータのみエクスポート可能
        PersonalDataExport export = protectionService.exportUserData(
            user.getUsername()
        );
        
        return ResponseEntity.ok()
            .header("Content-Disposition", 
                "attachment; filename=personal-data-export.json")
            .body(export);
    }
    
    /**
     * ロールに基づくマスキング
     */
    private ProtectedDataDto toMaskedDto(ProtectedEntity entity, UserDetails user) {
        ProtectedDataDto dto = new ProtectedDataDto();
        
        // 管理者は完全データを参照可能
        if (hasRole(user, "ADMIN") || hasRole(user, "DATA_PROTECTION_OFFICER")) {
            dto.setSensitiveData(entity.getSensitiveData());
        } else {
            // 一般ユーザーにはマスキング
            dto.setSensitiveData(entity.getMaskedSensitiveData());
        }
        
        return dto;
    }
}
```

### 9.4 テスト実装ガイドライン
```java
@SpringBootTest
@ActiveProfiles("test")
public class DataProtectionTest {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Autowired
    private TestEntityManager entityManager;
    
    /**
     * 暗号化・復号化テスト
     */
    @Test
    public void testEncryptionDecryption() {
        // Given
        String originalData = "Sensitive Information";
        DataClassification classification = DataClassification.HIGHLY_CONFIDENTIAL;
        
        // When
        EncryptedData encrypted = encryptionService.encrypt(originalData, classification);
        String decrypted = encryptionService.decrypt(encrypted, String.class);
        
        // Then
        assertThat(decrypted).isEqualTo(originalData);
        assertThat(encrypted.getData()).isNotEqualTo(originalData);
        assertThat(encrypted.getKeyId()).isNotNull();
    }
    
    /**
     * 検索可能暗号化テスト
     */
    @Test
    public void testSearchableEncryption() {
        // Given
        String searchTerm = "test@example.com";
        
        // When
        String hash1 = encryptionService.encryptForSearch(
            searchTerm, DataClassification.HIGHLY_CONFIDENTIAL);
        String hash2 = encryptionService.encryptForSearch(
            searchTerm, DataClassification.HIGHLY_CONFIDENTIAL);
        
        // Then
        assertThat(hash1).isEqualTo(hash2); // 同じ入力は同じハッシュ
        assertThat(hash1).isNotEqualTo(searchTerm); // 平文とは異なる
    }
    
    /**
     * GDPR削除権テスト
     */
    @Test
    @Transactional
    public void testGDPRDeletion() {
        // Given
        ProtectedEntity entity = createTestEntity();
        entityManager.persistAndFlush(entity);
        
        // When
        entity.requestDeletion("User request", "user123");
        entityManager.persistAndFlush(entity);
        
        // Then
        assertThat(entity.isDeletionRequested()).isTrue();
        assertThat(entity.getDeletionRequestedAt()).isNotNull();
        assertThat(entity.getRightsExercises()).hasSize(1);
    }
    
    /**
     * データマスキングテスト
     */
    @Test
    public void testDataMasking() {
        // Emailマスキング
        String email = "john.doe@example.com";
        String maskedEmail = encryptionService.mask(email, MaskingType.EMAIL);
        assertThat(maskedEmail).isEqualTo("jo***@***.com");
        
        // 電話番号マスキング
        String phone = "090-1234-5678";
        String maskedPhone = encryptionService.mask(phone, MaskingType.PHONE);
        assertThat(maskedPhone).isEqualTo("***-***-5678");
        
        // 名前マスキング
        String name = "Yamada Taro";
        String maskedName = encryptionService.mask(name, MaskingType.NAME);
        assertThat(maskedName).isEqualTo("Y***o");
    }
}
```

### 9.5 パフォーマンス最適化ガイドライン
```java
/**
 * 大量データ処理時の最適化
 */
@Service
public class BulkEncryptionService {
    
    private final ExecutorService executorService = 
        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    
    /**
     * バッチ暗号化処理
     */
    public CompletableFuture<List<EncryptedData>> encryptBatch(
            List<String> dataList, 
            DataClassification classification) {
        
        // バッチサイズ最適化
        int batchSize = 100;
        List<CompletableFuture<List<EncryptedData>>> futures = new ArrayList<>();
        
        for (int i = 0; i < dataList.size(); i += batchSize) {
            int end = Math.min(i + batchSize, dataList.size());
            List<String> batch = dataList.subList(i, end);
            
            CompletableFuture<List<EncryptedData>> future = 
                CompletableFuture.supplyAsync(() -> 
                    encryptBatchInternal(batch, classification),
                    executorService
                );
            
            futures.add(future);
        }
        
        // 結果の統合
        return CompletableFuture.allOf(
            futures.toArray(new CompletableFuture[0])
        ).thenApply(v -> 
            futures.stream()
                .map(CompletableFuture::join)
                .flatMap(List::stream)
                .collect(Collectors.toList())
        );
    }
    
    /**
     * インデックス最適化
     */
    @Entity
    @Table(indexes = {
        @Index(name = "idx_search_hash", columnList = "name_search_hash, email_search_hash"),
        @Index(name = "idx_classification", columnList = "data_classification"),
        @Index(name = "idx_deletion_requested", columnList = "deletion_requested")
    })
    public class OptimizedProtectedEntity extends PersonalDataEntity {
        // インデックス最適化されたエンティティ
    }
    
    /**
     * キャッシュウォーミング
     */
    @PostConstruct
    public void warmupCache() {
        // 頻繁にアクセスされるデータのプリロード
        List<String> frequentlyAccessedIds = getFrequentlyAccessedIds();
        
        frequentlyAccessedIds.parallelStream()
            .forEach(id -> cacheService.preloadEncryptedData(id));
    }
}
```

### 9.6 トラブルシューティング
```java
/**
 * データ保護トラブルシューティング
 */
@Slf4j
@Component
public class DataProtectionTroubleshooter {
    
    /**
     * 暗号化エラー診断
     */
    public void diagnoseEncryptionError(Exception e) {
        log.error("Encryption error diagnosis started", e);
        
        // キー管理サービスの状態確認
        if (!keyManagementService.isHealthy()) {
            log.error("Key Management Service is not healthy");
            log.error("Check: Environment variable ENCRYPTION_KEY_PATH");
            log.error("Check: Key file permissions (should be 600)");
        }
        
        // 暗号化アルゴリズムの確認
        try {
            Cipher.getInstance("AES/GCM/NoPadding");
        } catch (Exception ex) {
            log.error("AES-GCM algorithm not available");
            log.error("Check: Java Cryptography Extension (JCE) installation");
        }
        
        // メモリ不足の確認
        long freeMemory = Runtime.getRuntime().freeMemory();
        if (freeMemory < 100 * 1024 * 1024) { // 100MB
            log.warn("Low memory detected: {} MB", freeMemory / 1024 / 1024);
            log.warn("Consider increasing heap size with -Xmx");
        }
    }
    
    /**
     * パフォーマンス問題診断
     */
    @Scheduled(fixedDelay = 300000) // 5分ごと
    public void diagnosePerformance() {
        // 暗号化処理時間の計測
        long startTime = System.currentTimeMillis();
        String testData = "Performance test data";
        
        EncryptedData encrypted = encryptionService.encrypt(
            testData, DataClassification.INTERNAL);
        encryptionService.decrypt(encrypted, String.class);
        
        long duration = System.currentTimeMillis() - startTime;
        
        if (duration > 100) { // 100ms以上
            log.warn("Slow encryption detected: {} ms", duration);
            log.warn("Check: Key rotation schedule");
            log.warn("Check: Database connection pool size");
            log.warn("Check: Redis cache hit rate");
        }
    }
}
```

---

**作成者**: システム化プロジェクトチーム  
**最終更新**: 2025年6月2日