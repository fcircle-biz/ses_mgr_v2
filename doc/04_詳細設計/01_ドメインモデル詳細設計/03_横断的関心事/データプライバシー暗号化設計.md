# SES管理システム - データプライバシー・暗号化設計

## 1. データ分類とプライバシー要件

### 1.1 データ分類体系
```
データ分類レベル:
├── Level 1: 公開情報 (Public)
│   ├── システム設定情報
│   ├── マスタデータ（スキル名等）
│   └── 統計データ（匿名化済み）
├── Level 2: 社内限定 (Internal)
│   ├── プロジェクト基本情報
│   ├── 契約金額情報
│   └── 業務実績データ
├── Level 3: 機密情報 (Confidential)
│   ├── 顧客企業情報
│   ├── 個人スキル詳細
│   └── 勤務評価情報
└── Level 4: 極秘情報 (Highly Confidential)
    ├── 個人識別情報 (PII)
    ├── マイナンバー等
    └── 給与・報酬情報
```

### 1.2 GDPR/個人情報保護法対応
```java
/**
 * 個人データ保護アノテーション
 */
@Target({ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PersonalData {
    /**
     * データ分類レベル
     */
    DataClassification classification() default DataClassification.CONFIDENTIAL;
    
    /**
     * 暗号化必須フラグ
     */
    boolean encryptionRequired() default true;
    
    /**
     * マスキング必須フラグ
     */
    boolean maskingRequired() default false;
    
    /**
     * データ保持期間（年）
     */
    int retentionYears() default 7;
    
    /**
     * 削除権対象フラグ（GDPR Article 17）
     */
    boolean rightToErasure() default true;
    
    /**
     * ポータビリティ権対象フラグ（GDPR Article 20）
     */
    boolean rightToPortability() default true;
    
    /**
     * 処理目的
     */
    String[] processingPurposes() default {};
    
    /**
     * 法的根拠
     */
    LegalBasis legalBasis() default LegalBasis.LEGITIMATE_INTEREST;
    
    enum DataClassification {
        PUBLIC, INTERNAL, CONFIDENTIAL, HIGHLY_CONFIDENTIAL
    }
    
    enum LegalBasis {
        CONSENT,              // 同意
        CONTRACT,             // 契約履行
        LEGAL_OBLIGATION,     // 法的義務
        VITAL_INTERESTS,      // 生命に関わる利益
        PUBLIC_TASK,          // 公的業務
        LEGITIMATE_INTEREST   // 正当な利益
    }
}
```

## 2. 暗号化アーキテクチャ

### 2.1 暗号化アーキテクチャ概要
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Application    │    │ Encryption      │    │ Key Management  │
│  Layer          │    │ Service         │    │ Service (KMS)   │
│                 │    │                 │    │                 │
│ ・Entity保存    │───►│・フィールド暗号化│───►│・キー生成       │
│ ・データ参照    │    │・復号化         │    │・キーローテーション│
│ ・検索処理      │    │・検索可能暗号化  │    │・アクセス制御   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Database       │    │ Audit Service   │    │ Backup Service  │
│                 │    │                 │    │                 │
│ ・暗号化済み保存│    │・アクセスログ   │    │・暗号化バックアップ│
│ ・インデックス  │    │・操作ログ       │    │・キー分離保存   │
│ ・パフォーマンス│    │・異常検知       │    │・復旧手順       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2.2 暗号化サービス実装
```java
@Service
public class EncryptionService {
    private final KeyManagementService keyService;
    private final AuditService auditService;
    
    // AES-256-GCM for field-level encryption
    private static final String ALGORITHM = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;
    
    /**
     * フィールドレベル暗号化
     */
    public EncryptedData encrypt(Object data, DataClassification classification) {
        if (data == null) {
            return null;
        }
        
        try {
            // データ分類に応じたキー取得
            EncryptionKey key = keyService.getKey(classification);
            
            // データの文字列化
            String plaintext = objectToJson(data);
            byte[] plaintextBytes = plaintext.getBytes(StandardCharsets.UTF_8);
            
            // 暗号化実行
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            byte[] iv = generateIV();
            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key.getSecretKey(), gcmSpec);
            
            byte[] encryptedBytes = cipher.doFinal(plaintextBytes);
            
            // 監査ログ
            auditService.logEncryption(key.getKeyId(), classification, plaintextBytes.length);
            
            return new EncryptedData(
                Base64.getEncoder().encodeToString(encryptedBytes),
                Base64.getEncoder().encodeToString(iv),
                key.getKeyId(),
                Instant.now()
            );
            
        } catch (Exception e) {
            auditService.logEncryptionFailure(classification, e.getMessage());
            throw new EncryptionException("Encryption failed", e);
        }
    }
    
    /**
     * フィールドレベル復号化
     */
    public <T> T decrypt(EncryptedData encryptedData, Class<T> targetType) {
        if (encryptedData == null) {
            return null;
        }
        
        try {
            // キー取得
            EncryptionKey key = keyService.getKey(encryptedData.getKeyId());
            
            // 復号化実行
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            byte[] iv = Base64.getDecoder().decode(encryptedData.getIv());
            byte[] encryptedBytes = Base64.getDecoder().decode(encryptedData.getData());
            
            GCMParameterSpec gcmSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, key.getSecretKey(), gcmSpec);
            
            byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
            String decryptedText = new String(decryptedBytes, StandardCharsets.UTF_8);
            
            // 監査ログ
            auditService.logDecryption(encryptedData.getKeyId(), targetType.getSimpleName());
            
            return jsonToObject(decryptedText, targetType);
            
        } catch (Exception e) {
            auditService.logDecryptionFailure(encryptedData.getKeyId(), e.getMessage());
            throw new DecryptionException("Decryption failed", e);
        }
    }
    
    /**
     * 検索可能暗号化（Deterministic Encryption）
     */
    public String encryptForSearch(String plaintext, DataClassification classification) {
        if (plaintext == null || plaintext.isEmpty()) {
            return null;
        }
        
        try {
            // 検索用キー（固定IV使用）
            EncryptionKey searchKey = keyService.getSearchKey(classification);
            
            // HMAC-SHA256による決定的暗号化
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(searchKey.getSecretKey());
            byte[] hashBytes = mac.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
            
            return Base64.getEncoder().encodeToString(hashBytes);
            
        } catch (Exception e) {
            throw new EncryptionException("Search encryption failed", e);
        }
    }
    
    /**
     * データマスキング
     */
    public String mask(String data, MaskingType type) {
        if (data == null || data.isEmpty()) {
            return data;
        }
        
        switch (type) {
            case EMAIL:
                return maskEmail(data);
            case PHONE:
                return maskPhone(data);
            case CREDIT_CARD:
                return maskCreditCard(data);
            case NAME:
                return maskName(data);
            case PARTIAL:
                return maskPartial(data);
            default:
                return "***MASKED***";
        }
    }
    
    private String maskEmail(String email) {
        if (!email.contains("@")) return "***@***.***";
        
        String[] parts = email.split("@");
        String localPart = parts[0];
        String domain = parts[1];
        
        String maskedLocal = localPart.length() > 2 ? 
            localPart.substring(0, 2) + "***" : "***";
        String maskedDomain = domain.contains(".") ? 
            "***." + domain.substring(domain.lastIndexOf(".") + 1) : "***";
            
        return maskedLocal + "@" + maskedDomain;
    }
    
    private String maskPhone(String phone) {
        String digits = phone.replaceAll("[^0-9]", "");
        if (digits.length() < 4) return "***-***-****";
        
        return "***-***-" + digits.substring(digits.length() - 4);
    }
    
    private String maskName(String name) {
        if (name.length() <= 1) return "*";
        if (name.length() <= 3) return name.charAt(0) + "*";
        
        return name.charAt(0) + "***" + name.charAt(name.length() - 1);
    }
    
    private String maskPartial(String data) {
        if (data.length() <= 4) return "***";
        
        int visibleChars = Math.min(2, data.length() / 4);
        return data.substring(0, visibleChars) + "***" + 
               data.substring(data.length() - visibleChars);
    }
    
    private byte[] generateIV() {
        byte[] iv = new byte[GCM_IV_LENGTH];
        new SecureRandom().nextBytes(iv);
        return iv;
    }
    
    private String objectToJson(Object obj) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.writeValueAsString(obj);
    }
    
    private <T> T jsonToObject(String json, Class<T> type) throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(json, type);
    }
    
    public enum MaskingType {
        EMAIL, PHONE, CREDIT_CARD, NAME, PARTIAL, FULL
    }
}
```

### 2.3 暗号化データクラス
```java
@Embeddable
public class EncryptedData {
    private String data;              // Base64エンコードされた暗号化データ
    private String iv;                // Base64エンコードされたIV
    private String keyId;             // 暗号化キーID
    private Instant encryptedAt;      // 暗号化日時
    
    public EncryptedData() {}
    
    public EncryptedData(String data, String iv, String keyId, Instant encryptedAt) {
        this.data = data;
        this.iv = iv;
        this.keyId = keyId;
        this.encryptedAt = encryptedAt;
    }
    
    // ゲッター・セッターメソッド省略
}
```

## 3. 個人データ管理エンティティ

### 3.1 PersonalDataEntity（個人データ基底クラス）
```java
@MappedSuperclass
public abstract class PersonalDataEntity {
    
    /**
     * データ主体（本人）の同意管理
     */
    @Embedded
    private ConsentManagement consentManagement;
    
    /**
     * データ保持期間管理
     */
    @Embedded
    private RetentionManagement retentionManagement;
    
    /**
     * アクセス履歴
     */
    @ElementCollection
    private List<DataAccessLog> accessLogs;
    
    /**
     * 削除要求フラグ
     */
    private boolean deletionRequested;
    private LocalDateTime deletionRequestedAt;
    private String deletionReason;
    
    /**
     * 匿名化フラグ
     */
    private boolean anonymized;
    private LocalDateTime anonymizedAt;
    
    /**
     * GDPR権利行使記録
     */
    @ElementCollection
    private List<RightsExerciseLog> rightsExercises;
    
    /**
     * データアクセス記録
     */
    public void recordAccess(String userId, String purpose) {
        DataAccessLog log = new DataAccessLog();
        log.setUserId(userId);
        log.setPurpose(purpose);
        log.setAccessedAt(LocalDateTime.now());
        log.setIpAddress(getCurrentIpAddress());
        
        this.accessLogs.add(log);
        
        // 異常アクセス検知
        detectAnomalousAccess();
    }
    
    /**
     * 削除権行使（GDPR Article 17）
     */
    public void requestDeletion(String reason, String requesterId) {
        this.deletionRequested = true;
        this.deletionRequestedAt = LocalDateTime.now();
        this.deletionReason = reason;
        
        RightsExerciseLog log = new RightsExerciseLog();
        log.setRightType(GDPRRight.RIGHT_TO_ERASURE);
        log.setRequesterId(requesterId);
        log.setRequestedAt(LocalDateTime.now());
        log.setReason(reason);
        
        this.rightsExercises.add(log);
    }
    
    /**
     * 匿名化実行
     */
    public void anonymize() {
        if (this.anonymized) {
            return;
        }
        
        anonymizePersonalData();
        
        this.anonymized = true;
        this.anonymizedAt = LocalDateTime.now();
    }
    
    /**
     * データポータビリティ権対応（GDPR Article 20）
     */
    public PersonalDataExport exportPersonalData() {
        PersonalDataExport export = new PersonalDataExport();
        export.setDataSubjectId(getDataSubjectId());
        export.setExportedAt(LocalDateTime.now());
        export.setData(collectPersonalData());
        export.setFormat("JSON");
        
        RightsExerciseLog log = new RightsExerciseLog();
        log.setRightType(GDPRRight.RIGHT_TO_PORTABILITY);
        log.setRequestedAt(LocalDateTime.now());
        
        this.rightsExercises.add(log);
        
        return export;
    }
    
    /**
     * 保持期間チェック
     */
    public boolean isRetentionPeriodExpired() {
        return retentionManagement.isExpired();
    }
    
    /**
     * 同意状況チェック
     */
    public boolean hasValidConsent(String purpose) {
        return consentManagement.hasValidConsent(purpose);
    }
    
    // 抽象メソッド
    protected abstract String getDataSubjectId();
    protected abstract void anonymizePersonalData();
    protected abstract Map<String, Object> collectPersonalData();
    
    private void detectAnomalousAccess() {
        // 異常アクセスパターンの検知ロジック
        long recentAccesses = accessLogs.stream()
            .filter(log -> log.getAccessedAt().isAfter(LocalDateTime.now().minusHours(1)))
            .count();
            
        if (recentAccesses > 100) {
            // アラート送信
            SecurityAlertService.sendAnomalousAccessAlert(getDataSubjectId(), recentAccesses);
        }
    }
    
    private String getCurrentIpAddress() {
        // 現在のリクエストのIPアドレス取得
        return RequestContextHolder.getRequestIpAddress();
    }
}
```

### 3.2 ConsentManagement（同意管理）
```java
@Embeddable
public class ConsentManagement {
    
    @ElementCollection
    private Map<String, ConsentRecord> consents; // 目的別同意記録
    
    /**
     * 同意の記録
     */
    public void recordConsent(String purpose, ConsentType type, String legalBasis) {
        ConsentRecord record = new ConsentRecord();
        record.setPurpose(purpose);
        record.setType(type);
        record.setLegalBasis(legalBasis);
        record.setGrantedAt(LocalDateTime.now());
        record.setVersion("1.0");
        record.setActive(true);
        
        consents.put(purpose, record);
    }
    
    /**
     * 同意の撤回
     */
    public void withdrawConsent(String purpose, String reason) {
        ConsentRecord record = consents.get(purpose);
        if (record != null) {
            record.setActive(false);
            record.setWithdrawnAt(LocalDateTime.now());
            record.setWithdrawalReason(reason);
        }
    }
    
    /**
     * 有効な同意の確認
     */
    public boolean hasValidConsent(String purpose) {
        ConsentRecord record = consents.get(purpose);
        return record != null && record.isActive() && !record.isExpired();
    }
    
    /**
     * 同意履歴のエクスポート
     */
    public List<ConsentRecord> exportConsentHistory() {
        return new ArrayList<>(consents.values());
    }
    
    @Embeddable
    public static class ConsentRecord {
        private String purpose;               // 処理目的
        private ConsentType type;            // 同意タイプ
        private String legalBasis;           // 法的根拠
        private LocalDateTime grantedAt;     // 同意日時
        private LocalDateTime withdrawnAt;    // 撤回日時
        private String withdrawalReason;      // 撤回理由
        private String version;              // 同意バージョン
        private boolean active;              // 有効フラグ
        private LocalDateTime expiresAt;     // 有効期限
        
        public boolean isExpired() {
            return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);
        }
        
        // ゲッター・セッターメソッド省略
    }
    
    public enum ConsentType {
        EXPLICIT,    // 明示的同意
        IMPLIED,     // 黙示的同意
        OPT_IN,      // オプトイン
        OPT_OUT      // オプトアウト
    }
}
```

### 3.3 暗号化フィールドコンバーター
```java
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, EncryptedData> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public EncryptedData convertToDatabaseColumn(String plaintext) {
        if (plaintext == null) {
            return null;
        }
        
        // アノテーションから暗号化レベル取得
        DataClassification classification = getClassificationFromContext();
        return encryptionService.encrypt(plaintext, classification);
    }
    
    @Override
    public String convertToEntityAttribute(EncryptedData encryptedData) {
        if (encryptedData == null) {
            return null;
        }
        
        return encryptionService.decrypt(encryptedData, String.class);
    }
    
    private DataClassification getClassificationFromContext() {
        // 実行コンテキストからアノテーション情報を取得
        return DataClassification.CONFIDENTIAL; // デフォルト
    }
}

@Converter
public class EncryptedEmailConverter implements AttributeConverter<EmailAddress, EncryptedData> {
    
    @Autowired
    private EncryptionService encryptionService;
    
    @Override
    public EncryptedData convertToDatabaseColumn(EmailAddress email) {
        if (email == null) {
            return null;
        }
        
        return encryptionService.encrypt(email.getValue(), DataClassification.HIGHLY_CONFIDENTIAL);
    }
    
    @Override
    public EmailAddress convertToEntityAttribute(EncryptedData encryptedData) {
        if (encryptedData == null) {
            return null;
        }
        
        String decryptedEmail = encryptionService.decrypt(encryptedData, String.class);
        return new EmailAddress(decryptedEmail);
    }
}
```

## 4. Engineer集約への暗号化適用例

### 4.1 暗号化対応Engineer集約
```java
@Entity
@Table(name = "engineers")
public class Engineer extends PersonalDataEntity {
    
    @Id
    private EngineerId id;
    
    // === 個人識別情報（高度機密） ===
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true,
        processingPurposes = {"契約管理", "給与計算"},
        legalBasis = LegalBasis.CONTRACT
    )
    @Convert(converter = EncryptedStringConverter.class)
    private String fullName;
    
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true,
        processingPurposes = {"連絡業務"},
        legalBasis = LegalBasis.CONTRACT
    )
    @Convert(converter = EncryptedEmailConverter.class)
    private EmailAddress email;
    
    @PersonalData(
        classification = DataClassification.HIGHLY_CONFIDENTIAL,
        encryptionRequired = true
    )
    @Convert(converter = EncryptedStringConverter.class)
    private String phoneNumber;
    
    // === 検索可能な暗号化フィールド ===
    @Column(name = "name_search_hash")
    private String nameSearchHash; // 検索用ハッシュ
    
    @Column(name = "email_search_hash")
    private String emailSearchHash; // 検索用ハッシュ
    
    // === 機密情報 ===
    @PersonalData(
        classification = DataClassification.CONFIDENTIAL,
        encryptionRequired = true,
        processingPurposes = {"スキル評価", "マッチング"}
    )
    @Convert(converter = EncryptedSkillSetConverter.class)
    private SkillSet skillSet;
    
    // === 社内限定情報 ===
    @PersonalData(
        classification = DataClassification.INTERNAL,
        encryptionRequired = false,
        maskingRequired = true
    )
    private WorkStatus workStatus;
    
    /**
     * 暗号化フィールドの保存前処理
     */
    @PrePersist
    @PreUpdate
    private void generateSearchHashes() {
        if (fullName != null) {
            nameSearchHash = encryptionService.encryptForSearch(
                fullName, DataClassification.HIGHLY_CONFIDENTIAL);
        }
        if (email != null) {
            emailSearchHash = encryptionService.encryptForSearch(
                email.getValue(), DataClassification.HIGHLY_CONFIDENTIAL);
        }
        
        // アクセス記録
        recordAccess(getCurrentUserId(), "データ更新");
    }
    
    /**
     * 匿名化実装
     */
    @Override
    protected void anonymizePersonalData() {
        this.fullName = "匿名ユーザー" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
        this.email = new EmailAddress("anonymous@company.com");
        this.phoneNumber = "000-0000-0000";
        
        // スキルセットは統計的価値があるため匿名化のみ
        this.skillSet = this.skillSet.anonymize();
        
        // 検索ハッシュも更新
        generateSearchHashes();
    }
    
    /**
     * 個人データ収集
     */
    @Override
    protected Map<String, Object> collectPersonalData() {
        Map<String, Object> data = new HashMap<>();
        data.put("fullName", fullName);
        data.put("email", email != null ? email.getValue() : null);
        data.put("phoneNumber", phoneNumber);
        data.put("skillSet", skillSet);
        data.put("workStatus", workStatus);
        return data;
    }
    
    @Override
    protected String getDataSubjectId() {
        return id.getValue();
    }
    
    /**
     * マスキング表示用メソッド
     */
    public String getMaskedName() {
        return encryptionService.mask(fullName, EncryptionService.MaskingType.NAME);
    }
    
    public String getMaskedEmail() {
        return email != null ? 
            encryptionService.mask(email.getValue(), EncryptionService.MaskingType.EMAIL) : null;
    }
    
    public String getMaskedPhone() {
        return encryptionService.mask(phoneNumber, EncryptionService.MaskingType.PHONE);
    }
}
```

### 4.2 暗号化対応Repository
```java
@Repository
public interface EngineerRepository extends JpaRepository<Engineer, EngineerId> {
    
    /**
     * 暗号化ハッシュによる名前検索
     */
    @Query("SELECT e FROM Engineer e WHERE e.nameSearchHash = :nameHash")
    List<Engineer> findByNameHash(@Param("nameHash") String nameHash);
    
    /**
     * 暗号化ハッシュによるメール検索
     */
    @Query("SELECT e FROM Engineer e WHERE e.emailSearchHash = :emailHash")
    Optional<Engineer> findByEmailHash(@Param("emailHash") String emailHash);
    
    /**
     * 削除要求済みエンジニア一覧
     */
    @Query("SELECT e FROM Engineer e WHERE e.deletionRequested = true")
    List<Engineer> findDeletionRequestedEngineers();
    
    /**
     * 保持期間切れエンジニア一覧
     */
    @Query("SELECT e FROM Engineer e WHERE e.retentionManagement.expiresAt < :currentDate")
    List<Engineer> findRetentionExpiredEngineers(@Param("currentDate") LocalDateTime currentDate);
}

/**
 * 暗号化対応検索サービス
 */
@Service
public class EncryptedEngineerSearchService {
    
    private final EngineerRepository engineerRepository;
    private final EncryptionService encryptionService;
    
    /**
     * 名前による検索（暗号化対応）
     */
    public List<Engineer> searchByName(String name) {
        String nameHash = encryptionService.encryptForSearch(
            name, DataClassification.HIGHLY_CONFIDENTIAL);
        return engineerRepository.findByNameHash(nameHash);
    }
    
    /**
     * メールアドレスによる検索（暗号化対応）
     */
    public Optional<Engineer> findByEmail(String email) {
        String emailHash = encryptionService.encryptForSearch(
            email, DataClassification.HIGHLY_CONFIDENTIAL);
        return engineerRepository.findByEmailHash(emailHash);
    }
    
    /**
     * 部分マッチ検索（復号化して検索）
     * 注意: パフォーマンスが悪いため、必要な場合のみ使用
     */
    public List<Engineer> searchByNamePartial(String partialName) {
        List<Engineer> allEngineers = engineerRepository.findAll();
        
        return allEngineers.stream()
            .filter(engineer -> {
                String decryptedName = engineer.getFullName();
                return decryptedName != null && 
                       decryptedName.toLowerCase().contains(partialName.toLowerCase());
            })
            .collect(Collectors.toList());
    }
}
```

## 5. データ保護運用

### 5.1 定期クリーンアップジョブ
```java
@Component
public class DataProtectionScheduler {
    
    private final EngineerRepository engineerRepository;
    private final DataDeletionService dataDeletionService;
    
    /**
     * 保持期間切れデータの自動削除
     */
    @Scheduled(cron = "0 0 2 * * ?") // 毎日2時実行
    public void cleanupRetentionExpiredData() {
        LocalDateTime currentDate = LocalDateTime.now();
        List<Engineer> expiredEngineers = engineerRepository.findRetentionExpiredEngineers(currentDate);
        
        for (Engineer engineer : expiredEngineers) {
            if (engineer.canBeDeleted()) {
                dataDeletionService.safeDelete(engineer);
            } else {
                engineer.anonymize();
                engineerRepository.save(engineer);
            }
        }
    }
    
    /**
     * 削除要求処理
     */
    @Scheduled(cron = "0 30 2 * * ?") // 毎日2:30実行
    public void processDeletionRequests() {
        List<Engineer> deletionRequested = engineerRepository.findDeletionRequestedEngineers();
        
        for (Engineer engineer : deletionRequested) {
            dataDeletionService.processGDPRDeletion(engineer);
        }
    }
}
```

### 5.2 データ保護監査サービス
```java
@Service
public class DataProtectionAuditService {
    
    /**
     * GDPR準拠監査
     */
    public GDPRAuditReport generateGDPRAuditReport() {
        GDPRAuditReport report = new GDPRAuditReport();
        
        // 個人データ処理活動の記録
        report.setProcessingActivities(auditProcessingActivities());
        
        // 同意管理状況
        report.setConsentManagement(auditConsentManagement());
        
        // データ保護影響評価
        report.setDPIA(auditDataProtectionImpact());
        
        // セキュリティ措置
        report.setSecurityMeasures(auditSecurityMeasures());
        
        return report;
    }
    
    /**
     * データブリーチ検知
     */
    public void detectDataBreach() {
        // 異常なデータアクセスパターンの検知
        // 大量データ抽出の検知
        // 不正なデータ変更の検知
    }
}
```

---

**作成者**: システム化プロジェクトチーム  
**最終更新**: 2025年6月1日